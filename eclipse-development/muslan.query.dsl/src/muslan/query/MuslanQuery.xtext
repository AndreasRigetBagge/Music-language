// common terminals loaded for use in our language
grammar muslan.query.MuslanQuery with org.eclipse.xtext.common.Terminals
//important dependencies
import "https://www.example.org/query" 
import "https://www.example.org/collection" as collection
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

//autoGenerated by XText
//Query returns Query:
//	'Query'
//	'{'
//		'type' type=PlayItemType
//		'collection' collection=[collection::Collection|EString]
//		'filter' filter=FilterClause
//	'}';

//syntax rule for query
// ***check if |EString needs to apply
Query:
	"pick" type=PlayItemType "from" collection=[collection::Collection|EString] "with"
	filter=FilterClause
;

//autoGenerated by XText
//FilterClause returns FilterClause:
//	AndClause | OrClause | CategoryClause | ArtistClause | TitleClause;

//The beginning of the recursive structure
//It (is in principle an And-clause)
//Contains a number of orClauses followed by a global set of and-clauses
FilterClause returns AndClause:
	 filterclause+=OrClause "andFinally" filterclause+=AndFinallyClause
;

//used for splitting up rules
Clause:
	CategoryClause | ArtistClause | TitleClause
;

//Seems like what we want 
/* 
CategorizedElement returns collection::CategorizedElement:
	Track | Album | Composition
;
*/

//autoGenerated by XText
//Collection returns collection::Collection:
//	{collection::Collection}
//	'Collection'
//	'{'
//		('Name' Name=EString)?
//		('categorizedelements' '{' categorizedelements+=CategorizedElement ( "," categorizedelements+=CategorizedElement)* '}' )?
//	'}';

//Rule for collection. Just a string
//Just the name-property when using ID ***
Collection returns collection::Collection:
	Name=ID
;


//Rule for enum
enum PlayItemType:
	Track = 'Track' | Album = 'Album'
;

/* Can be string or ID for now??***  */
EString returns ecore::EString:
	STRING | ID
;

/*** maybe not needed
Artist returns collection::Artist:
	{collection::Artist}
	'Artist'
	'{'
		('Name' Name=EString)?
	'}';
*/

/**maybe not needed 
Category returns collection::Category:
	'Category'
	'{'
		'CategoryType' CategoryType=CategoryType
		('Value' Value=EString)?
	'}';
*/

/**Maybe not needed 
 * 
 * 
 * 
Track returns collection::Track:
	{collection::Track}
	'Track'
	'{'
		('Name' Name=EString)?
		('artists' '(' artists+=[collection::Artist|EString] ( "," artists+=[collection::Artist|EString])* ')' )?
		('category' '(' category+=[collection::Category|EString] ( "," category+=[collection::Category|EString])* ')' )?
		('compositions' '(' compositions+=[collection::Composition|EString] ( "," compositions+=[collection::Composition|EString])* ')' )?
	'}';
*/

/* 
Album returns collection::Album:
	'Album'
	'{'
		('Name' Name=EString)?
		('artists' '(' artists+=[collection::Artist|EString] ( "," artists+=[collection::Artist|EString])* ')' )?
		('category' '(' category+=[collection::Category|EString] ( "," category+=[collection::Category|EString])* ')' )?
		'tracks' '(' tracks+=[collection::Track|EString] ( "," tracks+=[collection::Track|EString])* ')' 
	'}';
*/

/* 
Composition returns collection::Composition:
	{collection::Composition}
	'Composition'
	'{'
		('Name' Name=EString)?
		('artists' '(' artists+=[collection::Artist|EString] ( "," artists+=[collection::Artist|EString])* ')' )?
		('category' '(' category+=[collection::Category|EString] ( "," category+=[collection::Category|EString])* ')' )?
		('tracks' '(' tracks+=[collection::Track|EString] ( "," tracks+=[collection::Track|EString])* ')' )?
	'}';
*/

enum CategoryType returns collection::CategoryType:
				Rating = 'Rating' | Genre = 'Genre' | Tag = 'Tag'
;

/* autogenerated from XText
AndClause returns AndClause:
	'AndClause'
	'{'
		'filterclause' '{' filterclause+=FilterClause ( "," filterclause+=FilterClause)* '}' 
	'}';
*/



/*Autogenerated by XText 
OrClause returns OrClause:
	'OrClause'
	'{'
		'filterclause' '{' filterclause+=FilterClause ( "," filterclause+=FilterClause)* '}' 
	'}';
*/

//Constitutes the units of an Or-clause as a number of clauses (separated as And-clauses), each separated with .'s
//structured as to avoid left-recursion-problems
OrClause:
	filterclause+=AndClause "." filterclause+=NextOrClause
;

//the "next" element in the recursive structure, either ending it or continuing it
NextOrClause returns FilterClause:
	AndClause "." | OrClause
;

//Constitutes the units of an And-clause as a number of clauses, each separated with .'s
AndClause:
	filterclause+=Clause "," filterclause+=NextAndClause
;

NextAndClause returns FilterClause:
	Clause | AndClause
;


//The AndFinally-clause is put at last and denotes a number of and-clauses that comes at last.
//This denotes the globally applicable and-clauses (as they otherwise has precedence in this structure)
AndFinallyClause returns FilterClause:
	AndClause 
;

//Generated by XText:
/* 
CategoryClause returns CategoryClause:
	'CategoryClause'
	'{'
		'value' value=EString
		'operator' operator=OperatorType
		'category' category=CategoryType
	'}';
*/

//Simply lists the three specified attributes in the following order
CategoryClause:
	category=CategoryType operator=OperatorType value=EString
;

//Autogenerated by Xtext:
/* 
ArtistClause returns ArtistClause:
	'ArtistClause'
	'{'
		'value' value=EString
		'operator' operator=OperatorType
	'}';
*/

//Uses artist keyword followed by an operator for a restricted subset of operators followed by the value
ArtistClause:
	"artist" operator=RestrictedOperatorType value=EString
;

//autogenerated by XText
/* 
TitleClause returns TitleClause:
	'TitleClause'
	'{'
		'value' value=EString
		'operator' operator=OperatorType
	'}';
*/

TitleClause:
	"title" operator=RestrictedOperatorType value=EString
;


enum OperatorType returns OperatorType:
				SameAs = 'SameAs' | DifferentFrom = 'DifferentFrom' | LessThan = 'LessThan' | GreaterThan = 'GreaterThan';

//Used for artistclause and title-clause as it doesn't make sense to use greater-than or less-than on those
enum RestrictedOperatorType returns OperatorType:
				SameAs = 'SameAs' | DifferentFrom = 'DifferentFrom';

